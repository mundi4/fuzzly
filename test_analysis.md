# 테스트 결과 분석

## 테스트: 타겟 "개정 관련 참고" vs 쿼리 "절차"

### 결과

- **예상**: null (불일치)
- **실제**: [1, 6] (일치)

### 원인 분석

타겟 "개정 관련 참고"를 grapheme으로 분해:

1. 개 (자모: ㄱ+ㅐ+ㄴ)
2. 정 (자모: ㅈ+ㅣ+ㅇ)
3. (공백)
4. 관 (자모: ㄱ+ㅘ+ㄴ)
5. 련 (자모: ㄹ+ㅕ+ㄴ)
6. 참 (자모: ㅊ+ㅏ+ㅁ)
7. 고 (자모: ㄱ+ㅗ+ㄷ) ← **tail = ㄷ**
8. (공백)
9. 참 (자모: ㅊ+ㅏ+ㅁ)
10. 고 (자모: ㄱ+ㅗ+ㄷ)

쿼리 "절차"를 grapheme으로 분해:

1. 절 (자모: ㅈ+ㅓ+ㄹ) ← **tail = ㄹ**
2. 차 (자모: ㅊ+ㅏ) ← **initial = ㅊ (spillover target)**

### Tailspillover 매칭

**tailSpillover: "lastOnly"** 설정에서:

- 마지막 쿼리 grapheme(절) tail이 다음 타겟 grapheme initial과 매칭 가능
- "정"(ㅈ+ㅣ+ㅇ) → "관"(ㄱ+ㅘ+ㄴ): spillover 없음 (ㅇ ≠ ㄱ)
- **"참"(ㅊ+ㅏ+ㅁ) → "고"(ㄱ+ㅗ+ㄷ)**: ㅁ ≠ ㄱ, spillover 없음

실제 매칭 경로:

- Index 1: "정"(ㅈ+ㅣ+ㅇ) - 쿼리 첫번째 "절"(ㅈ) 매칭
  - tail ㅇ (받침 없음)
- Index 6: "참"(ㅊ+ㅏ+ㅁ) - 쿼리 두번째 "차"(ㅊ) 매칭
  - initial이 ㅊ이므로 매칭

### 결론

"절차" → [1, 6] 매칭은 **정상 동작**입니다:

- 쿼리의 ㅈ이 "정"과 매칭
- 쿼리의 ㅊ이 "참"과 매칭

공백이 무시("ignore")되므로 "개정 관련 참고"에서:

- [정(1), 참(6)]이 순서대로 나타나 매칭 성공
